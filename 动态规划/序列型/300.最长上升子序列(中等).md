给定一个无序的整数数组，找到其中最长上升子序列的长度。

***

动态规划+二分

这里的二分查找是一个优化，一般很难想到，也可以选择线性查找

dp[i] : 最长上升子序列的值大小为i时，对应序列末尾的值(取最小的情况)，这里利用了dp数组的下标。
dp数组是一个递增的序列：序列越长，它对应的末尾的元素值就越大，因为dp[i]维护着长度为i的上升序列的末尾的最小值。

```Java
public int lengthOfLIS(int[] nums) {
    int[] dp = new int[nums.length + 1];
    int res = 0;

    dp[0] = Integer.MIN_VALUE;
    
    int i, j = 0, start, end, mid;

    for (i = 0; i < nums.length; i++) {
        start = 0; 
        end = res;

        while (start <= end) {
            mid = (start + end) / 2;
            if (dp[mid] < nums[i]) {
                j = mid;
                start = mid + 1;
            }else {
                end = mid - 1;
            }
        }
        dp[j + 1] = nums[i];
        if (j + 1 > res) {
            res = j + 1;
        }
    }
    return res;
}
```