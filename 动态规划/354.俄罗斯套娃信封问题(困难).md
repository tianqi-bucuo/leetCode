给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

***
对数组元素排好序后，就可以对高度按照 300.最长上升子序列 的方式求解。
同理，这里的二分查找也是个优化方案，很难想到，可以替换为线性查找。

```Java
public int maxEnvelopes(int[][] envelopes) {
    if (envelopes.length == 0) return 0;

    // 对envelopes按宽度递增，高度递减排序
    Arrays.sort(envelopes, new Comparator<int[]>() {
        @Override
        public int compare(int[] a, int[] b) {
            if (a[0] == b[0]) return b[1] - a[1];
            return a[0] - b[0];
        }
    });

    // 获取高度序列
    int len = envelopes.length;
    int[] height = new int[len];
    for (int i = 0; i < len; i ++) {
        height[i] = envelopes[i][1];
    }

    // 动态规划+二分查找
    int[] dp = new int[len + 1];
    int maxLen = 1;
    dp[maxLen] = height[0];
    for (int i = 0; i < len; i ++) {

        // 当前位置的值大于dp中最后位置（maxLen位置）的值，则直接在后面插入
        if (height[i] > dp[maxLen])
            dp[++ maxLen] = height[i];

        // 否则对dp中已存在的值进行替换
        else {
            // 使用二分查找查找当前位置的值在dp中的插入位置，并对该位置的值进行替换
            // 由于对于相同宽度的信封，其高度总是递减的，因此对于相同宽度的信封，总会是高度小的替换高度大的
            // 且不会存在相同宽度信封共存的情况
            // 又因为是从dp[1]开始存储信封，因此，最终maxLen的值即为最大信封数
            int index = Arrays.binarySearch(dp, 0, maxLen + 1, height[i]);
            if (index < 0) index = -(index + 1);
            dp[index] = height[i];
        }
    }
    return maxLen;
}
```