给定 n 件物品，物品的重量为 weight[i]，物品的价值为 value[i]。现挑选物品放入背包中，假定背包能承受的最大重量为 capacity，问应该如何选择装入背包中的物品，使得装入背包中物品的总价值最大？

![](https://s1.ax1x.com/2020/06/09/tIncZT.png)

```Java
int knapsack01(int[] weight, int[] value, int capacity){
    int n = weight.length;
    if(n == 0)
        return 0;
    int[][] dp = new int[n][capacity + 1];
    // 初始化只有第一个物品的情况
    for(int j = 0; j <= capacity; j++)
        dp[0][j] = (j >= weight[j] ? value[j] : 0);
    for(int i = 1; i < n; i++){
        for(int j = 0; j <= capacity; j++){
            // 不考虑放入第i个物品
            dp[i][j] = dp[i - 1][j];
            // 考虑放入第i个物品
            if(weight[i] <= j)
                dp[i][j] = Math.max(dp[i - 1][j], v[i] + dp[i - 1][j - weight[i]]);      
        }
    }
    return dp[n - 1][capacity];
}
```

以上方法的时间和空间复杂度均为O(VN)，其中时间复杂度应该已经不能再优化了，但空间复杂度却可以优化到O(n)。
伪代码如下：

```C++
for i=1..N
    for v=V..0
        f[v]=max{f[v],f[v-c[i]]+w[i]};
```
其中的f[v]=max{f[v],f[v-c[i]]}一句恰就相当于我们的转移方程f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]}，因为现在的f[v-c[i]]就相当于原来的f[i-1][v-c[i]]。

## 初始化的细节问题
我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。

如果是第一种问法，要求恰好装满背包，那么在初始化时除了f[0]为0其它f[1..V]均设为-∞，这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。

如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将f[0..V]全部设为0。

为什么呢？可以这样理解：初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。

这个小技巧完全可以推广到其它类型的背包问题，后面也就不再对进行状态转移之前的初始化进行讲解。
