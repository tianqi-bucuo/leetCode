请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。

## 方法一:动态规划
```Java
class Solution {

    public boolean isMatch(String s, String p){
        int lenS = s.length(), lenP = p.length();

        // dp[i][j]代表p的前i个字符p[0...i-1]和s的前j个字符s[0...j-1]是否匹配
        boolean[][] dp = new boolean[lenP + 1][lenS + 1];
        // s的前0个字符和p的前0个字符(空和空)肯定是匹配的
        dp[0][0] = true;
        // 初始化第一行和第一列
        // 当p为空，s不为空，肯定匹配失败，dp[0][1...lenS]为false
        // 当s为空，p不为空，只有p为a*b*c*...这种形式才为true
        for(int i = 2; i <= lenP; i = i + 2)
            dp[i][0] = dp[i - 2][0] && p.charAt(i - 1) == '*';
        
        for(int i = 0; i < lenP; i++){
            for(int j = 0; j < lenS; j++){
                if(p.charAt(i) == '*'){
                    // 两种情况
                    // '*'和它前面的字符 匹配s的0个字符，这种情况需要dp[i-1][j+1]匹配成功
                    // '*'和它前面的字符 匹配s的1个或多个字符，这种情况需要dp[i+1][j]匹配成功，且s的当前字符与'*'前面那个字符匹配
                    dp[i + 1][j + 1] = dp[i - 1][j + 1] || (dp[i + 1][j] && match(p, s, i - 1, j));
                }else{
                    dp[i + 1][j + 1] = dp[i][j] && match(p, s, i, j);
                }
            }
        }
        return dp[lenP][lenS];
    }

    //判断p第i个字符和s第j个字符是否匹配
    private boolean match(String p,String s,int i,int j){
        return s.charAt(j)==p.charAt(i)||p.charAt(i)=='.';
    }
}
```

## 方法二:回溯

```Java
class Solution {
    public boolean isMatch(String s, String p) {
        if(p.isEmpty()) return s.isEmpty();
        if(p.length() == 1){
            return p.equals(s) || (p.equals(".") && s.length() == 1);
            //'*'的下标肯定大于等于1，如果大于1，这种情况会在后面的递归中遇到
        }else if(p.length() >= 2 && p.charAt(1) == '*'){
            return (
            //这里对应的是'*'匹配到了1个或多个它前面的元素
            ((!s.isEmpty() && (p.charAt(0) == s.charAt(0) || p.charAt(0) == '.')) && isMatch(s.substring(1), p)) 
            //这里对应的是'*'匹配了0个它前面的那一个元素
            || isMatch(s, p.substring(2)) 
            );
        }else{
            return (!s.isEmpty() && (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.')) && isMatch(s.substring(1), p.substring(1));
        }
    }
}
```