给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。  

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。  

你可以假设 nums1 和 nums2 不会同时为空。  


第k大问题:在logn时间内找到数组中第k大的数

quickSelection算法：
1. 随机抓取一个元素，猜测它是第k大的。定义为轴点pivot
2. 元素数组中，大于pivot的元素放在数组右边，小于pivot的元素放在数组左边。完毕时，pivot定位，秩为i，数组分成三部分，小于pivot的左数组，等于pivot的元素，大于pivot的右数组。此时，pivot恰好为元素中第i大的元素。
3. 如果k小于i，则在左数组中重复执行1)-2)步；否则，在右数组中重复执行1)-2)步。
4. 基于以上逐步逼近的思想，最终会收敛到一个确定的秩，即为所求第k大的元素。


问题中的两个数组已经有序，比较两个数组第k/2位置的元素，较小的数组可以直接删除前k/2个元素，
然后k = k/2,递归此过程，直到某一数组删除完或 k==1 。

找中位数可以看成是第k大的特例:k = (nums1.length + nums.length) / 2

```Java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n = nums1.length + nums2.length;
        
        //如果n为奇数，结果为中间两个数的平均
        if (n % 2 == 0) {
            return (
                findHelper(nums1, 0, nums2, 0, n / 2) + 
                findHelper(nums1, 0, nums2, 0, n / 2 + 1)
            ) / 2.0;
        }
        
        return findHelper(nums1, 0, nums2, 0, n / 2 + 1);
    }

    public int findHelper(int A[], int startOfA, 
                          int B[], int startOfB,
                          int k){
        //当A数组中的数已被全部排除
        if (startOfA >= A.length) {
            return B[startOfB + k - 1];
        }
        //当B数组中的数已被全部排除
        if (startOfB >= B.length) {
            return A[startOfA + k - 1];
        }
        //递归出口
        if (k == 1) {
            return Math.min(A[startOfA], B[startOfB]);
        }
        //k超出某个数组下标的情况
        int halfKthOfA = startOfA + k / 2 - 1 < A.length
            ? A[startOfA + k / 2 - 1]
            : Integer.MAX_VALUE;
        int halfKthOfB = startOfB + k / 2 - 1 < B.length
            ? B[startOfB + k / 2 - 1]
            : Integer.MAX_VALUE; 
        //递归
        if (halfKthOfA < halfKthOfB) {
            return findHelper(A, startOfA + k / 2, B, startOfB, k - k / 2);
        } else {
            return findHelper(A, startOfA, B, startOfB + k / 2, k - k / 2);
        }
    }

}
```

